# -*- coding: utf-8 -*-
module Stone
  module Ast
    TRUE = 1  
    FALSE = 0
    
    # ここから下、しばらくクラスのオーバーライド（既存のクラスにメソッドを加えてる）
    
    class AstTree
      def eval(env)
      end   
    end
    
    class AstList
      def eval(env)
        raise 'cannot eval'
      end
    end
    
    class AstLeaf
      def eval(env)
        raise 'cannot eval'
      end
    end
    
    class NumberLiteral
      def eval(env)
        self.value
      end
    end
    
    class StringLiteral
      
      def initialize(token)
        super(token)
      end
      
      def eval(env)
        self.value
      end
    end
    
    class Name
      
      def initialize(token)
        super(token)
      end
      
      def eval(env)
        value = env.get(self.name)
      end
    end
    
    class NegativeExpr
      
      def initialize(children)
        super(children)
      end
      
      def eval(env)
        value = self.operand.eval(env)
        
        if value.is_a?(Integer)
          -(v.to_i)
        else
          raise 'bad type for - '
        end
      end
    end
    
    
    class BinaryExpr
      
      def initialize(children)
        super(children)
      end
      
      def eval(env)
        op = self.operator  
        # javaのequalsはRubyの==と同じ. 値が等しいかどうかを調べる.
        if "=" == op
          right = self.right.eval(env)
          return ComputeAssign.new(env, right)
        else
          left = self.left.eval(env)
          right = self.right.eval(env)
          return ComputeOp.new(left, op, right)
        end
      end
    end
    
    
    # クラスのオーバーライドここまで
    
    class ComputeAssign
      
      def initialize(env, rvalue)
        @list = self.left
      end
      
      if @list.is_a?(Name)
        env.put(@list.name, rvalue)
        return rvalue
      else
        
      end
    end
    
    class ComputeOp
      def initialize(left, op, right)
        if (left.is_a?(Integer) and right.is_a?(Integer))
          return ComputeNumber.new(left.to_i, op, right.to_i)
        else
          if op == "+"
            return left.to_s + right.to_s
          elsif op == "=="
            if left == nil
              if right == nil then TRUE else FALSE end
            else
              if left == right then TRUE else FALSE end
            end
          else
            
          end
        end
      end
    end
    
    class ComputeNumber
      def initialize(left, op, right)
        @left = left
        @op = op
        @right = right
      end
      a = @left.to_i
      b = @right.to_i
      
      case @op
        when "+" then a + b
        when "-" then a - b
        when "*" then a * b
        when "/" then a / b
        when "%" then a % b
        when "=="
          if a == b then TRUE else FALSE end
        when ">"
          if a > b then TRUE else FALSE end
        when "<"
          if a < b then TRUE else FALSE end
        else

      end
    end

    #あ、またクラスオーバーライドの始まり
    
    class BlockStmnt
      
      def initialize(children)
        super(children)
      end
      
      def eval(env)
        result = 0
        self.each do |tree|
          unless tree.kind_of?(NullStmnt) then result = tree.eval(env) end
        end
        return result
      end
    end
    
    class IfStmnt
      
      def initialize(children)
        super(children)
      end
      
      def eval(env)
        condition = self.condition.eval(env)
        if (condition.is_a?(Integer) && condition.to_i != FALSE)
          self.then_block.eval(env)
        else
          block = self.else_block
          if block == nil then 0 else block.eval(env) end
        end
      end
    end
    
    class WhileStmnt
      
      def initialize(children)
        super(children)
      end
      
      def eval(env)
        result = 0
        loop do
          condition = self.condition.eval(env)
          if (condition.is_a?(Integer) && condition.to_i == FALSE)
            result
          else
            result = self.body.eval(env)
          end
        end
      end
    end
    # クラスのオーバーライドここまで（2回目）
  end
end
